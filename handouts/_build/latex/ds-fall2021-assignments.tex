%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{DS\sphinxhyphen{}Fall2021\sphinxhyphen{}Assignments}
\date{Aug 30, 2021}
\release{}
\author{RBS}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}

\begin{document}

\pagestyle{empty}

\pagestyle{plain}

\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{C++ Language Constructs: Week01}
\label{\detokenize{constructs-week01:c-language-constructs-week01}}\label{\detokenize{constructs-week01::doc}}

\section{Simplistic C++ Programs}
\label{\detokenize{constructs-week01:simplistic-c-programs}}
\sphinxAtStartPar
C++ allows procedural\sphinxhyphen{}style programs (just like C).
Input and output is done using stream\sphinxhyphen{}operators


\subsection{A Minimal C++ Program}
\label{\detokenize{constructs-week01:a-minimal-c-program}}
\sphinxAtStartPar
Program \sphinxcode{\sphinxupquote{sample01.cpp}} adds two integer numbers, prints their sum.
Pay attention to the signature of \sphinxcode{\sphinxupquote{main()}} method (it should returns integer);
near the end there is an optional line \sphinxcode{\sphinxupquote{return 0}} which means that
the process exited normally.

\fvset{hllines={, 4, 10,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Enter two numbers:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{v1} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v2} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{v1} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{v2}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{v1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ + }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{v2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{v1} \PYG{o}{+} \PYG{n}{v2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Sample standard input (\sphinxcode{\sphinxupquote{STDIN}}) for this program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
3 5
\end{sphinxVerbatim}

\sphinxAtStartPar
Sample standard output (\sphinxcode{\sphinxupquote{STDOUT}}) for this program and the input:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Enter two numbers:
3 + 5 = 8
\end{sphinxVerbatim}


\subsection{Reading Input with “while” Loop}
\label{\detokenize{constructs-week01:reading-input-with-while-loop}}
\sphinxAtStartPar
Program \sphinxcode{\sphinxupquote{sample02.cpp}} reads and adds all positive numbers on a single line; it ignores all input
after the first negative number or zero (as well as all input on subsequent lines).
\begin{itemize}
\item {} 
\sphinxAtStartPar
It reads standard input line by line; command \sphinxcode{\sphinxupquote{getline}} reads everything up to a newline symbol into
a \sphinxcode{\sphinxupquote{string}} variable \sphinxcode{\sphinxupquote{line}}.

\item {} 
\sphinxAtStartPar
It builds  a string\sphinxhyphen{}stream object \sphinxcode{\sphinxupquote{lineStream}} to read from this input.

\item {} 
\sphinxAtStartPar
It starts reading integer numbers from this input (every integer ends with some whitespace).

\item {} 
\sphinxAtStartPar
It exits the loop as soon as the end of the first line is reached (or there is a negative number in the input).

\end{itemize}

\fvset{hllines={, 9, 10, 12,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{line}\PYG{p}{;}
    \PYG{n}{getline}\PYG{p}{(}\PYG{n}{cin}\PYG{p}{,}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{stringstream} \PYG{n}{lineStream}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{num} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{while} \PYG{p}{(}\PYG{n}{lineStream} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{num} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{num} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{num}\PYG{p}{;} 
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Total is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{total} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Sample standard input (\sphinxcode{\sphinxupquote{STDIN}}) for this program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
3 5 7 9 \PYGZhy{}1 3 3 3
2 4 6
\end{sphinxVerbatim}

\sphinxAtStartPar
Sample standard output (\sphinxcode{\sphinxupquote{STDOUT}}) for this program and the input:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Total is 24
\end{sphinxVerbatim}


\subsection{Reading Input with “for” Loop}
\label{\detokenize{constructs-week01:reading-input-with-for-loop}}
\sphinxAtStartPar
Program \sphinxcode{\sphinxupquote{sample03.cpp}} asks the user to input the count of numbers \sphinxcode{\sphinxupquote{n}}.
After that it reads all \sphinxcode{\sphinxupquote{n}} integers and adds them up.
Note that the \sphinxcode{\sphinxupquote{for}} loop consists of three parts separated with semicolons
(initialization of the loop variable,
loop condition and increment that is done after each loop iteration).

\fvset{hllines={, 11,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Enter the count of numbers: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{n}\PYG{p}{;} 
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Enter }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ integers: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} 
    \PYG{k+kt}{int} \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} 
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{num}\PYG{p}{;} 
        \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{num}\PYG{p}{;} 
        \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{num}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The total of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ numbers is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{total} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Sample standard input (\sphinxcode{\sphinxupquote{STDIN}}) for this program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
10
1 2 3 4 5 6 7 8 9 10
\end{sphinxVerbatim}

\sphinxAtStartPar
Sample standard output (\sphinxcode{\sphinxupquote{STDOUT}}) for this program and the input:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Enter the count of numbers:
Enter 10 integers:
The total of 10 numbers is 55
\end{sphinxVerbatim}


\section{Fixed\sphinxhyphen{}size Arrays}
\label{\detokenize{constructs-week01:fixed-size-arrays}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
               \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
               \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Integer Data Types}
\label{\detokenize{constructs-week01:integer-data-types}}
\sphinxAtStartPar
Register overflow happens silently without warning:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{numbers}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1000000001}\PYG{p}{,} \PYG{l+m+mi}{1000000002}\PYG{p}{,}
                  \PYG{l+m+mi}{1000000003}\PYG{p}{,} \PYG{l+m+mi}{1000000004}\PYG{p}{,} \PYG{l+m+mi}{1000000005}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{sz} \PYG{o}{=} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{numbers}\PYG{p}{)}\PYG{o}{/}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// assigns array size (=5).}
\PYG{k+kt}{int} \PYG{n}{iTotal}\PYG{p}{;}             \PYG{c+c1}{// 4 byte register (signed)}
\PYG{k+kt}{long} \PYG{k+kt}{unsigned} \PYG{n}{luTotal}\PYG{p}{;}  \PYG{c+c1}{// 4 bytes register (unsigned)}
\PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{n}{llTotal}\PYG{p}{;}      \PYG{c+c1}{// 8 bytes register (signed)}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{sz}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{intTotal} \PYG{o}{+}\PYG{o}{=} \PYG{n}{numbers}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
      \PYG{n}{luTotal} \PYG{o}{+}\PYG{o}{=} \PYG{n}{numbers}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
      \PYG{n}{llTotal} \PYG{o}{+}\PYG{o}{=} \PYG{n}{numbers}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
      \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}th partial sum is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{intTotal} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(int), }\PYG{l+s}{\PYGZdq{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{luTotal} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(long unsigned), }\PYG{l+s}{\PYGZdq{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{llTotal} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(long long).}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Float Data Types}
\label{\detokenize{constructs-week01:float-data-types}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{success} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;}
\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Wrong proportion: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1.0}\PYG{o}{*}\PYG{p}{(}\PYG{n}{success}\PYG{o}{/}\PYG{n}{total}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Correct proportion: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{o}{*}\PYG{n}{success}\PYG{o}{/}\PYG{n}{total}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+c1}{// output exactly 6 decimal places:}
\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{fixed} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{setprecision}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{o}{*}\PYG{n}{success}\PYG{o}{/}\PYG{n}{total}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Text Data Types}
\label{\detokenize{constructs-week01:text-data-types}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{staircase}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{string} \PYG{n}{spaces}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{,}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{string} \PYG{n}{hashes}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZsh{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{spaces} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{hashes} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{spaces} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will output the following triangle:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{    \PYGZsh{}\PYGZsh{}    }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{   \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}   }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{  \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}  }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}


\section{Vectors}
\label{\detokenize{constructs-week01:vectors}}
\sphinxAtStartPar
Vectors are list\sphinxhyphen{}like objects that can hold objects of the same type, for example,
\sphinxcode{\sphinxupquote{vector\textless{}int\textgreater{}}} means a vector of \sphinxcode{\sphinxupquote{int}} variables (4\sphinxhyphen{}byte integer numbers).
See \sphinxhref{https://www.geeksforgeeks.org/initialize-a-vector-in-cpp-different-ways/}{Initialize a vector in C++}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// initialize a vector with the given elements}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{primes}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{17}\PYG{p}{,}\PYG{l+m+mi}{19}\PYG{p}{,}\PYG{l+m+mi}{23}\PYG{p}{,}\PYG{l+m+mi}{29}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{vectorSumAsArray}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{result} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{v}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{result} \PYG{o}{+}\PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you want to access vector without using “array syntax” (\sphinxcode{\sphinxupquote{v{[}i{]}}}),
you can use method \sphinxcode{\sphinxupquote{v.at(i)}} to access \(i\)\sphinxhyphen{}th element of a vector.
In this case we have a square\sphinxhyphen{}sized
vector of vectors and add up the elements on its diagonal:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{diagonalDifference}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{diag} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{arr}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{diag} \PYG{o}{+}\PYG{o}{=} \PYG{n}{arr}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{diag}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here is another method to operate with vectors: create iterator and loop over it.
For vectors it is not much different from the above method (accessing vector like an array).
But for some data structures iterator is more flexible as it does not need to know the size
of the data structure.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{vectorSumWithIter}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{result} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it} \PYG{o}{=} \PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{it}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{result} \PYG{o}{+}\PYG{o}{=} \PYG{o}{*}\PYG{n}{it}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Exercises}
\label{\detokenize{constructs-week01:exercises}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Input file contains a positive array size \(n\) and after that there are \(n\)
integers. Find the count of sign flips (when a positive number
is immediately followed by a negative number or vice versa).

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Input:} \sphinxcode{\sphinxupquote{0 \sphinxhyphen{}2 0 \sphinxhyphen{}10 2 \sphinxhyphen{}1 0 0 3 2 \sphinxhyphen{}3}}

\sphinxAtStartPar
\sphinxstylestrong{Output:} \sphinxcode{\sphinxupquote{3}}

\sphinxAtStartPar
\sphinxstyleemphasis{Explanation:} \sphinxcode{\sphinxupquote{10}} is followed by \sphinxcode{\sphinxupquote{2}}, \sphinxcode{\sphinxupquote{2}} is followed by \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}}, \sphinxcode{\sphinxupquote{2}} is followed by \sphinxcode{\sphinxupquote{\sphinxhyphen{}3}}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Input file contains positive integers \(m\) and \(n\); after that there are \(m \cdot n\)
integers \sphinxhyphen{} a rectangular matrix with \(m\) rows and \(n\) columns; the matrix is input row
by row.

\sphinxAtStartPar
Replace every matrix element \(a_{ij}\) by the smallest element of a submatrix
\(A’(i,j)\) (this submatrix has size \(i \times j\); it is located in the upper left corner
of the original matrix \(A\).

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Input:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
3 4
3 8 4 6
2 7 1 5
0 9 \PYGZhy{}1 2
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Output:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
3 4
3 3 3 3
2 2 1 1
0 0 \PYGZhy{}1 \PYGZhy{}1
\end{sphinxVerbatim}

\sphinxAtStartPar
Is it possible to compute the result without allocating new memory to hold \(O(mn)\) integers?
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
The input contains \(n\), the count of numbers followed by \(n\) integers.
Find the smallest integer and also find, how many numbers are equal to this smallest integer.

\end{enumerate}



\renewcommand{\indexname}{Index}
\printindex
\end{document}